[
  {
    "type": "choice",
    "question": "Чому в JavaScript потрібен асинхронний код?",
    "answers": [
      "Для прискорення виконання всього коду.",
      "Щоб уникнути блокування основного потоку виконання під час \"повільних\" операцій, таких як завантаження даних.",
      "Для спрощення синтаксису.",
      "JavaScript не підтримує синхронний код."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Що представляє собою Promise (проміс) в JavaScript?",
    "answers": [
      "Функцію, яка виконує асинхронну операцію.",
      "Об'єкт, що представляє поточний стан асинхронної операції.",
      "Синхронну операцію.",
      "Значення, яке завжди відоме на момент створення."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Скільки основних станів може мати проміс?",
    "answers": [
      "Один",
      "Два",
      "Три",
      "Чотири"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Як називається початковий стан промісу під час його створення?",
    "answers": [
      "Fulfilled",
      "Rejected",
      "Settled",
      "Pending"
    ],
    "correct": 3
  },
  {
    "type": "choice",
    "question": "В який стан переходить проміс, якщо асинхронна операція виконана успішно з будь-яким результатом?",
    "answers": [
      "Pending",
      "Rejected",
      "Fulfilled",
      "Settled"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "В який стан переходить проміс, якщо асинхронна операція відхилена з помилкою?",
    "answers": [
      "Pending",
      "Fulfilled",
      "Rejected",
      "Settled"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Чи може стан промісу змінитися після того, як він перейшов у стан \"виконано\" (fulfilled) або \"відхилено\" (rejected)?",
    "answers": [
      "Так, може повернутися до стану \"очікування\".",
      "Так, може перейти з \"виконано\" у \"відхилено\".",
      "Ні, після переходу в стан fulfilled або rejected він більше не змінює свій стан.",
      "Залежить від типу асинхронної операції."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Яким терміном описують проміс, який перебуває в будь-якому стані, крім \"очікування\" (pending)?",
    "answers": [
      "Active",
      "Resolved",
      "Completed",
      "Settled"
    ],
    "correct": 3
  },
  {
    "type": "choice",
    "question": "Як створюється новий проміс в JavaScript?",
    "answers": [
      "Викликом функції createPromise().",
      "Як екземпляр класу Promise за допомогою new Promise().",
      "За допомогою ключового слова async.",
      "Шляхом передачі колбеків у функцію."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Як називається функція, яка передається як аргумент конструктору new Promise() і відразу викликається?",
    "answers": [
      "Handler",
      "Callback",
      "Executor",
      "Resolver"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Яка функція викликається всередині виконавчої функції промісу (executor), щоб повідомити про успішне виконання операції та передати її результат?",
    "answers": [
      "reject()",
      "catch()",
      "resolve()",
      "then()"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Яка функція викликається всередині виконавчої функції промісу (executor), щоб повідомити про помилку виконання операції?",
    "answers": [
      "resolve()",
      "then()",
      "reject()",
      "finally()"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Який метод промісу використовується для реєстрації обробників успішного виконання та/або помилки?",
    "answers": [
      ".catch()",
      ".finally()",
      ".then()",
      ".resolve()"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Скільки аргументів (callback-функцій) може приймати метод .then()?",
    "answers": [
      "Один (для успіху)",
      "Два (перший для успіху, другий для помилки)",
      "Три (для успіху, помилки, і завершення)",
      "Жодного"
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Який метод промісу на практиці найчастіше використовується для обробки тільки помилок (відхиленого стану)?",
    "answers": [
      ".then() з двома аргументами",
      ".catch()",
      ".finally()",
      "try...catch"
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Після якого методу промісу зазвичай розташовується метод .catch() при побудові ланцюжка обробників?",
    "answers": [
      "Перед .then().",
      "Перед .finally().",
      "Після .then().",
      "Порядок не має значення."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Який метод промісу дозволяє виконати код незалежно від того, чи проміс виконався успішно чи з помилкою (тобто перейшов у стан settled)?",
    "answers": [
      ".then()",
      ".catch()",
      ".finally()",
      ".resolve()"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Чи отримує callback-функція, передана в метод .finally(), якісь аргументи?",
    "answers": [
      "Так, значення успішного виконання.",
      "Так, об'єкт помилки.",
      "Так, об'єкт зі статусом промісу.",
      "Ні, вона не отримує жодних аргументів."
    ],
    "correct": 3
  },
  {
    "type": "choice",
    "question": "Яка особливість методу .then() дозволяє формувати послідовність асинхронних операцій, зв'язуючи проміси в ланцюжок?",
    "answers": [
      "Він завжди виконується негайно.",
      "Він повертає новий проміс.",
      "Він приймає будь-яку кількість аргументів.",
      "Він автоматично обробляє всі помилки."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Що відбувається у ланцюжку промісів, якщо виникає помилка в одному з .then() обробників?",
    "answers": [
      "Виконання ланцюжка продовжується, і помилка ігнорується.",
      "Виконання всіх наступних .then() скасовується, а управління передається найближчому методу .catch().",
      "Весь код зупиняється з фатальною помилкою.",
      "Помилка передається як значення наступному .then()."
    ],
    "correct": 1
  }
]