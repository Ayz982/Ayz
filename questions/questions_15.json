[
  {
    "type": "choice",
    "question": "Яка головна мета розбиття кодової бази проєкту на окремі файли, кожен з яких описує окремий функціонал?",
    "answers": [
      "Зменшення загального розміру коду.",
      "Збільшення швидкості виконання програми.",
      "Модульність коду для кращої організації, обслуговування та управління залежностями.",
      "Використання різних мов програмування."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Яка перевага модульного коду полягає у створенні окремої області видимості для змінних, що запобігає конфліктам імен?",
    "answers": [
      "Підтримка",
      "Повторне використання",
      "Просторова оптимізація",
      "Простір імен"
    ],
    "correct": 3
  },
  {
    "type": "choice",
    "question": "Який сучасний стандарт системи модулів JavaScript відповідає за організацію та уніфікований підхід до імпорту та експорту даних між файлами?",
    "answers": [
      "CommonJS",
      "AMD",
      "ECMAScript Modules (ESM)",
      "UMD"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Що таке модуль в контексті ECMAScript Modules (ESM)?",
    "answers": [
      "HTML-файл з JavaScript-кодом.",
      "CSS-файл з правилами стилів.",
      "JavaScript-файл із фрагментом коду, який можна використовувати багато разів, експортуючи певні об'єкти.",
      "Файл конфігурації проєкту."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Яка конструкція використовується для реалізації експорту за замовчуванням (default export) в ESM?",
    "answers": [
      "export { name }",
      "import name from \"...\"",
      "export default exportedValue",
      "import { name as newName } }"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Скільки експортів за замовчуванням (default export) може бути в одному модулі ESM?",
    "answers": [
      "Необмежена кількість.",
      "Тільки один.",
      "Два.",
      "Не більше десяти."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Яка конструкція використовується для реалізації імпорту за замовчуванням (default import) в ESM?",
    "answers": [
      "export default ...",
      "import name from \"...\"",
      "import { name } from \"...\"",
      "export { name as newName }"
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Чи повинно ім'я, з яким імпортується значення за замовчуванням, збігатися з іменем, яке було використано при експорті за замовчуванням?",
    "answers": [
      "Так, завжди.",
      "Ні, ім'я може бути вибрано довільним чином.",
      "Тільки якщо це функція.",
      "Тільки якщо це змінна."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Який спосіб експортування дозволяє експортувати одне або кілька значень з модуля під конкретними, вказаними іменами?",
    "answers": [
      "Експорт за замовчуванням (default export).",
      "Іменований експорт (named export).",
      "Імпорт простору імен (namespace import).",
      "Динамічний імпорт."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Яка конструкція використовується для реалізації іменованого експорту (named export) в ESM?",
    "answers": [
      "export default ...",
      "import { name } from \"...\"",
      "export exportedValue (наприклад, export const name = ...;)",
      "import name from \"...\""
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Чи обмежена кількість іменованих експортів в одному модулі ESM?",
    "answers": [
      "Так, можна експортувати не більше одного.",
      "Так, можна експортувати не більше десяти.",
      "Ні, кількість іменованих експортів в одному модулі не обмежена.",
      "Залежить від браузера."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Яка конструкція використовується для реалізації іменованого імпорту (named import) в ESM?",
    "answers": [
      "export { name }",
      "import name from \"...\"",
      "import { name } from \"...\"",
      "export default ..."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Чи повинно ім'я, з яким імпортується іменоване значення, збігатися з іменем, яке було використано при іменованому експорті?",
    "answers": [
      "Ні, ім'я може бути вибрано довільним чином.",
      "Так, ім'я імпорту повинно збігатися з іменем експорту.",
      "Тільки якщо імпортується функція.",
      "Тільки якщо імпортується змінна."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Яке ключове слово використовується для перейменування іменованої сутності під час її імпорту з іншого модуля?",
    "answers": [
      "rename",
      "as",
      "alias",
      "with"
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Яка техніка дозволяє імпортувати весь вміст модуля (всі іменовані експорти) як властивості одного об'єкта з певним іменем?",
    "answers": [
      "Експорт за замовчуванням.",
      "Іменований імпорт.",
      "Перейменування імпорту.",
      "Імпорт простору імен (namespace import)."
    ],
    "correct": 3
  },
  {
    "type": "choice",
    "question": "Яка конструкція використовується для реалізації імпорту простору імен (namespace import)?",
    "answers": [
      "import name from \"...\"",
      "import { * as name } from \"...\"",
      "import * as name from \"...\"",
      "export * as name"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Якщо модуль експортує export const name = \"Mango\"; і ми використовуємо import * as user from './module.js';, як ми отримаємо доступ до значення змінної name через імпортований простір імен?",
    "answers": [
      "name",
      "user.name",
      "user.default.name",
      "user[\"name\"]"
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Яка перевага імпорту простору імен з точки зору уникнення конфліктів імен?",
    "answers": [
      "Він автоматично перейменовує всі імпортовані сутності.",
      "Всі іменовані експорти стають властивостями одного об'єкта, що дозволяє уникнути конфліктів з іменами в поточному модулі.",
      "Він імпортує лише ті сутності, яких ще немає в поточному модулі.",
      "Імпорт простору імен не впливає на конфлікти імен."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Чи імпортується експорт за замовчуванням (default export) автоматично при використанні імпорту простору імен import * as name from '...'?",
    "answers": [
      "Так, він стає властивістю default об'єкта простору імен.",
      "Ні, імпорт простору імен стосується лише іменованих експортів.",
      "Так, він стає основною властивістю об'єкта простору імен.",
      "Залежить від налаштувань експорту."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Яка з перерахованих переваг не стосується модульності коду відповідно до наданого матеріалу?",
    "answers": [
      "Краща підтримка та можливість розширення функціоналу.",
      "Запобігання забрудненню глобального простору імен.",
      "Складність тестування окремих частин коду.",
      "Можливість повторного використання коду."
    ],
    "correct": 2
  }
]