[
  {
    "type": "choice",
    "question": "Що таке Промісифікація?",
    "answers": [
      "Процес створення нового Promise.",
      "Перетворення функції, що приймає колбеки, на функцію, що повертає проміс.",
      "Використання async/await для обробки асинхронних операцій.",
      "Обробка декількох промісів одночасно."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Яка головна проблема callback-орієнтованих функцій з точки зору залежності від зовнішнього коду?",
    "answers": [
      "Вони не можуть виконувати асинхронні операції.",
      "Функція знає занадто багато про код, що використовуватиме результат її роботи, очікуючи конкретні колбеки.",
      "Вони завжди призводять до \"callback hell\".",
      "Вони не можуть повертати значення."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Що функція повертає у зовнішній код для обробки результату асинхронної операції?",
    "answers": [
      "Значення успішного виконання.",
      "Об'єкт помилки.",
      "Promise.",
      "Колбек-функцію."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Яка відмінність між колбеками та промісами з точки зору їхнього типу?",
    "answers": [
      "Колбеки — об'єкти, проміси — функції.",
      "Колбеки — рядки, проміси — числа.",
      "Колбеки — функції, проміси — об'єкти.",
      "Колбеки — змінні, проміси — константи."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Як колбеки передаються у функцію, що виконує асинхронну операцію?",
    "answers": [
      "Як значення, що повертається.",
      "Як аргументи функції.",
      "Через глобальну змінну.",
      "Як властивості об'єкта."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Де створюється проміс при промісифікації функції за допомогою new Promise()?",
    "answers": [
      "Зовні функції, перед її викликом.",
      "Всередині функції, що виконує асинхронну операцію.",
      "В глобальній області видимості.",
      "В окремому файлі."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Що використовується у зовнішньому коді для обробки успішного виконання промісу, повернутого промісифікованою функцією?",
    "answers": [
      "Метод .catch().",
      "Метод .then().",
      "Конструкція try...catch.",
      "Оператор await."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Що використовується у зовнішньому коді для обробки помилки (відхилення) промісу, повернутого промісифікованою функцією?",
    "answers": [
      "Метод .then().",
      "Метод .finally().",
      "Метод .catch().",
      "Оператор async."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Які статичні методи класу Promise використовуються для створення промісів, що миттєво успішно виконуються або відхиляються?",
    "answers": [
      "Promise.all() та Promise.race()",
      "Promise.resolve() та Promise.reject()",
      "Promise.allSettled() та Promise.any()",
      "Promise.create() та Promise.finish()"
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Для чого можуть використовуватися Promise.resolve() та Promise.reject() при промісифікації синхронних функцій?",
    "answers": [
      "Щоб додати затримку у виконання функції.",
      "Щоб створити ланцюжок промісів, коли вже є початкове значення і не потрібне очікування асинхронної операції.",
      "Для виконання HTTP-запитів.",
      "Для обробки декількох асинхронних подій одночасно."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Який метод використовується для створення промісу з різною затримкою виконання та можливістю успішного виконання або відхилення?",
    "answers": [
      "Promise.all()",
      "Promise.race()",
      "new Promise() у поєднанні з setTimeout()",
      "Promise.resolve()"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Який статичний метод класу Promise використовується, коли потрібно дочекатися виконання всіх промісів у масиві, і повернути результат у вигляді масиву значень, якщо всі успішні, або одразу відхилитись, якщо хоча б один відхилено?",
    "answers": [
      "Promise.race()",
      "Promise.allSettled()",
      "Promise.any()",
      "Promise.all()"
    ],
    "correct": 3
  },
  {
    "type": "choice",
    "question": "Що повертає Promise.all() у разі успішного виконання всіх промісів у масиві?",
    "answers": [
      "Значення першого промісу, що завершився.",
      "Масив об'єктів зі статусами та значеннями кожного промісу.",
      "Масив значень успішно виконаних промісів.",
      "undefined."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Що відбувається, якщо хоча б один проміс у масиві, переданому в Promise.all(), відхиляється?",
    "answers": [
      "Promise.all() чекає завершення всіх інших, а потім відхиляється.",
      "Promise.all() одразу відхиляється зі значенням помилки першого відхиленого промісу.",
      "Promise.all() ігнорує відхилений проміс і повертає результати успішних.",
      "Promise.all() повертає масив з результатами та помилками."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Який статичний метод класу Promise використовується, коли потрібно дочекатися завершення всіх промісів у масиві, незалежно від того, успішно вони виконані чи відхилені, і повернути масив об'єктів з описом результату кожного промісу?",
    "answers": [
      "Promise.all()",
      "Promise.race()",
      "Promise.allSettled()",
      "Promise.any()"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Що повертає Promise.allSettled()?",
    "answers": [
      "Масив значень успішно виконаних промісів.",
      "Значення першого промісу, що завершився.",
      "Масив об'єктів, кожен з яких описує результат (статус та значення/причину) відповідного промісу.",
      "Promise, який може бути відхилений, якщо хоча б один вхідний проміс відхилено."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Який статичний метод класу Promise повертає результат або помилку першого промісу в масиві, який завершився (успішно чи з помилкою)?",
    "answers": [
      "Promise.all()",
      "Promise.race()",
      "Promise.allSettled()",
      "Promise.any()"
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Якщо перший проміс у масиві, переданому в Promise.race(), відхиляється з помилкою, що поверне Promise.race()?",
    "answers": [
      "Результат першого успішно виконаного промісу.",
      "Помилку першого відхиленого промісу.",
      "Масив результатів усіх промісів.",
      "undefined."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Що відбувається з іншими промісами в масиві після того, як один з них завершився (успішно чи з помилкою) при використанні Promise.race()?",
    "answers": [
      "Вони продовжують виконуватися до завершення.",
      "Вони ігноруються і відкидаються.",
      "Вони також повертаються у результаті Promise.race().",
      "Вони стають частиною ланцюжка .then()."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Якщо функція fetchData використовує колбек з двома аргументами (error, result) для повідомлення про результат, як слід змінити цю функцію при промісифікації, щоб вона повертала проміс?",
    "answers": [
      "Функція повинна повертати null або undefined.",
      "Замість виклику колбека, вона повинна викликати resolve(result) у разі успіху або reject(error) у разі помилки всередині конструктора new Promise().",
      "Функція повинна використовувати async/await.",
      "Функція повинна повертати об'єкт з властивостями error та result."
    ],
    "correct": 1
  }
]