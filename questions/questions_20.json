[
  {
    "type": "choice",
    "question": "Який синтаксис називається зручним способом написання асинхронного коду, що виглядає схожим на синхронний?",
    "answers": [
      "Promise.then().catch()",
      "Callbacks",
      "async/await",
      "setTimeout"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "У якому стандарті ECMAScript був доданий синтаксис async/await?",
    "answers": [
      "ES6 (ECMAScript 2015)",
      "ES7 (ECMAScript 2016)",
      "ES8 (ECMAScript 2017)",
      "ES9 (ECMAScript 2018)"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Яке ключове слово необхідно додати перед оголошенням функції, щоб зробити її асинхронною?",
    "answers": [
      "await",
      "function",
      "async",
      "return"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Що завжди повертає асинхронна функція?",
    "answers": [
      "Значення, вказане у return.",
      "undefined, якщо немає return.",
      "Promise.",
      "Об'єкт."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Як обробляється значення, що повертається з асинхронної функції за допомогою ключового слова return, якщо це не Promise?",
    "answers": [
      "Воно ігнорується.",
      "Воно обгортається в Promise.resolve().",
      "Воно спричиняє помилку.",
      "Воно повертається як є."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Що повертається з асинхронної функції, якщо в ній не вказано значення для повернення за допомогою return?",
    "answers": [
      "null",
      "Promise зі значенням undefined.",
      "Помилка.",
      "Пустий об'єкт."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Для чого використовується оператор await всередині асинхронної функції?",
    "answers": [
      "Для оголошення змінної.",
      "Для створення нового Promise.",
      "Для очікування завершення Promise перед продовженням виконання коду.",
      "Для виклику іншої функції."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Де можна використовувати оператор await?",
    "answers": [
      "Будь-де в коді JavaScript.",
      "Тільки всередині звичайних синхронних функцій.",
      "Тільки всередині асинхронних функцій (оголошених з async).",
      "Тільки в глобальній області видимості."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Що відбувається з виконанням асинхронної функції, коли інтерпретатор зустрічає await перед Promise, який ще не завершився?",
    "answers": [
      "Функція завершує виконання з помилкою.",
      "Виконання функції призупиняється до завершення Promise.",
      "Код після await виконується негайно.",
      "Promise ігнорується, і функція продовжує роботу."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Яке значення повертає await, якщо Promise, на який він чекає, виконано успішно (fulfilled)?",
    "answers": [
      "undefined",
      "Значення, з яким виконано Promise.",
      "Promise об'єкт.",
      "null"
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Що відбувається, якщо Promise, на який чекає await, відхилено (rejected)?",
    "answers": [
      "await повертає значення помилки.",
      "Виконання функції продовжується, і помилка ігнорується.",
      "Виникає помилка, яку потрібно обробляти (наприклад, за допомогою try/catch).",
      "Promise перетворюється на успішний зі значенням undefined."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Яка основна перевага використання async/await при роботі з HTTP-запитами порівняно зі стандартним підходом на промісах (.then())?",
    "answers": [
      "Зменшення часу виконання запиту.",
      "Збільшення кількості одночасних запитів.",
      "Код виглядає послідовним, наче виконується синхронно, що покращує читабельність.",
      "Автоматична обробка всіх можливих помилок."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Яка конструкція використовується для обробки помилок, що можуть виникати під час виконання коду (зокрема, з async/await та HTTP-запитами)?",
    "answers": [
      "if...else",
      "switch...case",
      "try...catch",
      "while цикл"
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Якщо асинхронна функція з await повертає результат, як можна обробити помилку, що виникла всередині цієї функції, за межами її тіла?",
    "answers": [
      "Використовуючи try...catch всередині функції.",
      "Використовуючи .catch() при виклику асинхронної функції.",
      "Використовуючи finally() при виклику асинхронної функції.",
      "Помилка не може бути оброблена за межами функції."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Чому при роботі з великими колекціями даних на сервері (тисячі записів) не варто завантажувати всю колекцію за один запит?",
    "answers": [
      "Це збільшує безпеку даних.",
      "Це зменшує навантаження на мережу.",
      "Це спричиняє велике навантаження на браузер, тривалий час завантаження та навантаження на сервер.",
      "Це ускладнює сортування даних."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Який підхід використовується для оптимізації роботи з великими колекціями даних, коли сервер повертає лише частину записів за запитом?",
    "answers": [
      "Кешування даних на сервері.",
      "Пагінація.",
      "Використання стиснення даних.",
      "Потокова передача даних."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Як клієнт зазвичай вказує серверу, яку частину (групу або \"сторінку\") даних він хоче отримати при пагінації?",
    "answers": [
      "Через заголовки HTTP-запиту.",
      "Через тіло HTTP-запиту (POST).",
      "Через спеціальні параметри в URL запиту (наприклад, _page).",
      "Через WebSocket з'єднання."
    ],
    "correct": 2
  },
  {
    "type": "choice",
    "question": "Які типові назви параметрів використовуються в URL запиту для визначення кількості елементів у відповіді при пагінації?",
    "answers": [
      "id, name",
      "per_page, limit, _limit, count",
      "sort, order",
      "start, end"
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Як можна визначити на фронтенді, коли досягнуто кінця колекції при використанні пагінації, якщо сервер не повертає загальну кількість сторінок?",
    "answers": [
      "Порівнюючи номер поточної сторінки із загальною кількістю елементів.",
      "Перевіряючи, чи повернув сервер порожній масив або менше елементів, ніж очікувалося за лімітом, після останнього запиту.",
      "Використовуючи фіксоване значення для загальної кількості сторінок.",
      "Надсилаючи запит на отримання всіх елементів одразу."
    ],
    "correct": 1
  },
  {
    "type": "choice",
    "question": "Як розраховується загальна кількість сторінок (totalPages) на фронтенді, якщо бекенд надає лише загальну кількість елементів (totalItems) та відома кількість елементів на сторінці (limit)?",
    "answers": [
      "totalPages = totalItems - limit",
      "totalPages = totalItems / limit (з округленням вгору за необхідності)",
      "totalPages = totalItems + limit",
      "totalPages = totalItems * limit"
    ],
    "correct": 1
  }
]